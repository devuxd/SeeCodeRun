<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ACE and Esprima in Action!</title>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.3/ace.js" type="text/javascript" charset="utf-8"></script>
<!-- Init Scripts for Execution Trace API !-->
<script src="./scripts/esprima.js" type="text/javascript" charset="utf-8"></script>
<script src="./scripts/escodegen.browser.js" type="text/javascript" charset="utf-8"></script>
<script src="./scripts/esmorph.js" type="text/javascript" charset="utf-8"></script>
<script src="./scripts/executiontrace.js" type="text/javascript" charset="utf-8"></script>
<!-- End Scripts for Execution Trace API !-->

<style type="text/css" media="screen">
    #editor { 
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
    }
	
	#info{
		position:absolute;
		background-color: #F55;
		border-radius: 1px;
		top: 20px;
		left: 610px;
		width: 200px;
		z-index: 101;		
	}
	#stacktrace{
		position:absolute;
		background-color: #FF9;
		border-radius: 1px;
		top: 40px;
		left: 610px;
		width: auto;
		bottom: auto;
		z-index: 100;		
	}
	.seecoderun_tooltip {
		background-color: #FFF;
		background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));
		background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));
		border: 1px solid gray;
		border-radius: 1px;
		box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
		color: black;
		max-width: 100%;
		padding: 3px 4px;
		position: absolute;
		z-index: 10;
		-moz-box-sizing: border-box;
		-webkit-box-sizing: border-box;
		box-sizing: border-box;
		cursor: default;
		white-space: pre;
		word-wrap: break-word;
		line-height: normal;
		font-style: normal;
		font-weight: normal;
		letter-spacing: normal;
		pointer-events: none;
	}

	.ace_gutter-cell.seecoderun_annotation{
        background-color: #FFF;
        border-radius: 20px 0px 0px 20px; 
        box-shadow: 0px 0px 1px 1px red inset;
        background-repeat: no-repeat;
        background-position: 2px center;
    }
</style>
</head>
<body>
<pre id="editor">

Array.prototype.swap = function (i, j) {
    var k = this[i]; this[i] = this[j]; this[j] = k;
};

function bubbleSort(list) {
    var items = list.slice(0), swapped = false, p, q;
    for (p = 1; p < items.length; ++p) {
        for (q = 0; q < items.length - p; ++q) {
            if (items[q + 1] < items[q]) {
                items.swap(q, q + 1);
                swapped =true;
            }
        }
        if (!swapped) break;
    }
    return items;
}

var N = 5, data = []; while (N > 0) data.push(N--);
bubbleSort(data);

/*    
let x= 5;
let y = 6;

x = 7;
y = 8;


// other cases
var N = 5, data = [4, 5]; 

while (N > 0) 
    data.push(N--);

var x = { c :  N};
x.c++;
delete x.c;

let c= false, d= [];
var i, n=5;

if(c){
    var x=7;
}else{
    
}

for(let i= 0; i < 5; i++){
    d.push(i);
}
let z = d;
*/
</pre>
<div id="info" >Ready.</div>
<div id="stacktrace" >None</div>
<script>
	// initiating the editor
	var traceGutterData;
    var editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    editor.getSession().setMode("ace/mode/javascript");
	editor.renderer.setShowGutter(true);
	editor.session.setOption("useWorker", false);
	
	//gutter
	setTraceGutterRenderer(editor);
	var updateTooltip = function (position, text){
			//example with container creation via JS
			var div = document.getElementById('tooltip_0');
			if(div === null){
				div = document.createElement('div');		
				div.setAttribute('id', 'tooltip_0'); 
				div.setAttribute('class', 'seecoderun_tooltip'); // and make sure myclass has some styles in css
				document.body.appendChild(div);
			}

			div.style.left = position.pageX + 'px';
			div.style.top = position.pageY + 'px';
			if(text){
				div.style.display = "block";
				div.innerText = text;
			}else{
				div.style.display = "none";
				div.innerText = "";
			}			
			
	};
	// for tap/ click use guttermousedown
	editor.on("guttermousemove", function(e){ 
	    updateTooltip(editor.renderer.textToScreenCoordinates(e.getDocumentPosition()));
		let target = e.domEvent.target; 
		// si the element we want? for Ace cells "ace_gutter-cell", ours is
		if (target.className.indexOf("seecoderun_annotation") == -1){ 
			return;
		}
		// is this during user attention?
		if (!editor.isFocused()){ 
			return;
		}
		// is not the folding icon to the right of the line number?
		if (e.clientX > target.parentElement.getBoundingClientRect().right - 13){ 
			return; 
		}
		let row = e.getDocumentPosition().row;
		let text = ""
		if(traceGutterData.rows.hasOwnProperty(row)){
                let count = traceGutterData.rows[row]; 
                text = "This block has been called " + count + " times";
				let pixelPosition = editor.renderer.textToScreenCoordinates(e.getDocumentPosition());
				pixelPosition.pageY += editor.renderer.lineHeight;
				updateTooltip(pixelPosition, text);
			}else{
			//	updateTooltip(editor.renderer.textToScreenCoordinates(e.getDocumentPosition()));
			}
		e.stop(); 
		 
	});
	
    
    //Esprima
    // done: prepare demo from http://esprima.org/demo/functiontrace.html into this one 
    // done: look the required statements in the tree
    // todo: instrument the log of issue 16 [pending to catch the expression statement parent so code can be appended]
    // todo: collect the stack trace [ populate tree with callstack sequences]
    var canTrace = true;
    let aceAnnotations =[];
    window.onload = function () {
        'use strict';
        canTrace=true;
        window.CANTRACE =true;
    	
        document.getElementById('info').setAttribute('class', 'alert-box secondary');
        document.getElementById('info').innerHTML = 'Ready.';
        
    	var executionTrace = JSON.parse(localStorage.getItem('executionTrace'));
    	if(executionTrace){
    	    visualize(executionTrace.stackTrace);
    	}
    	
    	setTimeout(function(){  canTrace = true;}, 3000);
    	
    	var aceDocumentForEsprima = editor.getSession().getDocument(); // get the document for changes in its structure
    	aceDocumentForEsprima.on("change", function(e){
    	    var sourceCode = aceDocumentForEsprima.getValue(); // get the code to analyze
    	    // API CALL
    	    if(canTrace){
    	    	window.traceExecution(sourceCode, eventListener);
    	        canTrace = false;
    	        setTimeout(function(){  canTrace = true;}, 3000);
    	    }
    	   //  showTraceAnnotations(editor);
    	});
    // 	editor.getSession().on("changeAnnotation", function(e){
    //         showTraceAnnotations(editor);
    // 	});
    
    };
    
    // update the status of the trace run
    function eventListener (event){
        if(event.status === "Running"){
            document.getElementById('info').setAttribute('class', 'alert-box secondary');
            document.getElementById('info').innerHTML = event.description;
    		document.getElementById('stacktrace').innerHTML = 'Waiting...';        
        }else if(event.status === "Finished"){
            // traceAnnotations = window.getTraceAnnotations();
            
           // let aceAnnotations = getAnnotations();
           // addAceAnnotations(editor, aceAnnotations);
            updateTraceGutterData(editor);
            addTraceAnnotations(editor);
            
          
            document.getElementById('info').setAttribute('class', 'alert-box secondary');
            document.getElementById('info').innerHTML = event.description;
            var stackTrace = window.TRACE.getStackTrace();
            var valueTable = window.TRACE.getExecutionTrace();
            var executionTrace = {'stackTrace' : stackTrace, 'valueTable' : valueTable};
            localStorage.setItem('executionTrace', JSON.stringify(executionTrace));
    	//	document.getElementById('stacktrace').innerHTML ='LOCAL CALL STACK:<br>'+ visualize(stackTrace)+'<br>EXECUTION TRACE:<br>';
    	// 	 $('#stacktrace').append(visualizeExecutionTrace(valueTable));
    	
    	    //timeline
    	    let trace = window.TRACE.getVariables();
    		document.getElementById('stacktrace').innerHTML =
    		    'VARIABLES :<br>'+ visualizeExecutionTrace(trace.variables) +
    		    '<br>VALUES:<br>' + visualizeExecutionTrace(trace.values);
    	 
        }else if(event.status === "Error"){
            document.getElementById('info').innerHTML = event.description;
            document.getElementById('info').setAttribute('class', 'alert-box alert');
            document.getElementById('stacktrace').innerHTML = 'Waiting...';
        }else if(event.status === "Timeout"){
            document.getElementById('info').innerHTML = event.description;
            document.getElementById('info').setAttribute('class', 'alert-box alert');
            document.getElementById('stacktrace').innerHTML = 'Waiting...';
        }else if(event.status === "Busy"){
            document.getElementById('info').innerHTML = event.description;
            document.getElementById('info').setAttribute('class', 'alert-box alert');
            document.getElementById('stacktrace').innerHTML = 'Busy, please wait...';
        }
    }
    
    
    
    // example of how to use the trace resulting data structure
    function visualize(stackTrace){
        var i, entry, name, index;
        var stackText= "";
    	var repeat = 0;
    	var previousCall = "";
    	var previousIndex = -1;
        for (i = 0; i < stackTrace.length; i += 1) {
            entry = stackTrace[i];
            if(entry){
                name = entry.text;
        		index = entry.index;
        		 if(previousCall !== name){				 
        			 if(repeat > 0){
        				 stackText += previousIndex + " -- " + previousCall + "( + "+ repeat +" times) <br>";
        				 repeat = 0;
        			 }else{
        				 if(previousIndex > -1){
        					 stackText += previousIndex + " -- " + previousCall + "<br> ";
        				 }
        				 
        			 }
        			 previousCall = name;
        			 previousIndex = index;
        		 }else{
        			 repeat = repeat + 1; 
        		 }
            }
    		
        }
    	if(repeat > 0){
    		stackText +=  previousIndex + " -- " + previousCall + "( + "+ repeat +" times )";
    		repeat = 0;
    	}else{
    		if(previousIndex > -1){
    			stackText += previousIndex + " -- " + previousCall ;
    		}					 
    	}
    	
    	return stackText;  
    
    }
     // example of how to use the trace resulting data structure
    function visualizeExecutionTrace(executionTrace){
        var i, entry;
        var stackText= "";

        for (i = 0; i < executionTrace.length; i += 1) {
            entry = executionTrace[i];
            stackText += i + " -- " + JSON.stringify(entry) + "<br> ";
           
        }
       
    	
    	return stackText;  
    
    }
    
    function isPositioninRange(position, inRange){
        
        var matchesInOneLine = (
                position.row == inRange.start.row 
                && inRange.start.row  == inRange.end.row
                && position.column >= inRange.start.column
                && position.column <= inRange.end.column
            );
            
        if(matchesInOneLine){
            return true;
        }
            
        var matchesStart = (
                position.row == inRange.start.row 
                && inRange.start.row  < inRange.end.row
                && position.column >= inRange.start.column
            );
           
        if(matchesStart){
            return true;
        }
        
        var matchesEnd = (
                position.row == inRange.end.row
                && inRange.start.row  < inRange.end.row
                && position.column <= inRange.end.column
            );

        return matchesEnd;

    }
    function isRangeInRange(isRange, inRange){
        return (
                (isRange.start.row >= inRange.start.row && isRange.start.column >= inRange.start.column)
    			 &&
    			(isRange.end.row <= inRange.end.row && isRange.end.column <= inRange.end.column)
    			);
    }
    function isRangeInRangeStrict(isRange, inRange){
        return (
                (isRange.start.row >= inRange.start.row && isRange.start.column > inRange.start.column)
    			 &&
    			(isRange.end.row <= inRange.end.row && isRange.end.column < inRange.end.column)
    			);
    }
    
    editor.on("mousemove", function (e){
		var position = e.getDocumentPosition(),  hasUpdate =false, data, match;
		if(position){ 
		//console.log("mouse " + position.row + ", " + position.column);
		//	var wordRange = editor.getSession().getWordRange(position.row , position.column);
			var result = window.TRACE? window.TRACE.getExecutionTrace() : undefined;
			if(!result){
			    return;
			}
			
			for(var key in result){
			    data = result[key];
			    
    			 if(data.range && isPositioninRange(position, data.range)){
    			     if(match){
    			         if(isRangeInRangeStrict(data.range, match.range)){
    			             match = data;
    			         }
    			     }else{
    			        match = data;
    			     }
    			 
    			 }
			}
			if(match){
    				var pixelPosition = editor.renderer.textToScreenCoordinates(match.range.start);
    				pixelPosition.pageY += editor.renderer.lineHeight;
    				updateTooltip(pixelPosition, match.text +",  values"+ JSON.stringify(match.values));
    		}else{
    				updateTooltip(editor.renderer.textToScreenCoordinates(position));
    		}
			
		}
		});
		
		function updateTooltip(position, text){
			//example with container creation via JS
			var div = document.getElementById('tooltip_0');
			if(div === null){
				div = document.createElement('div');		
				div.setAttribute('id', 'tooltip_0'); 
				div.setAttribute('class', 'seecoderun_tooltip'); // and make sure myclass has some styles in css
				document.body.appendChild(div);
			}

			div.style.left = position.pageX + 'px';
			div.style.top = position.pageY + 'px';
			if(text){
				div.style.display = "block";
				div.innerText = text;
			}else{
				div.style.display = "none";
				div.innerText = "";
			}			
			
		}
		var traceAnnotations = [];
		function getTraceGutterCount(editor, aRow){
            var i, stackTrace, entry, text, row;
    
    		stackTrace = window.TRACE.getStackTrace();
            for (i = 0; i < stackTrace.length; i += 1) {
                entry = stackTrace[i];
                text = entry.text;
    			row = entry.range.start.row;
                if(row === aRow){
                    return entry.count;
                }
            }
            return 0;
		}
		
		function addTraceAnnotations(editor){
            var i, stackTrace, entry, text, row;
            
            // remove previous decorations
            if(traceAnnotations){
                for(i = 0; i< traceAnnotations.length; i++){
                    row = traceAnnotations[i]; 
                    editor.getSession().removeGutterDecoration(row, "seecoderun_annotation");
                }
            }
            
            traceAnnotations = [];
    		stackTrace = window.TRACE.getStackTrace();
    		var annotations = [];
            for (i = 0; i < stackTrace.length; i++) {
                entry = stackTrace[i];
                text = entry.text;
    			row = entry.range.start.row;
                editor.getSession().addGutterDecoration(row, "seecoderun_annotation");
                traceAnnotations.push(row);
            }	    
		}
		function removeTraceAnnotations(){
		    traceAnnotations = [];
		}
		function getAnnotations(){
            var i, stackTrace, entry, text, row;
    
    		stackTrace = window.TRACE.getStackTrace();
    		var annotations = [];
            for (i = 0; i < stackTrace.length; i += 1) {
                entry = stackTrace[i];
                text = entry.text;
    			row = entry.range.start.row;
    			
    			annotations.push({ type: "info", row: row, raw: " y is called x times", text: text + ' is called ' + entry.count + ' times'});
                
            }
            return annotations;
        }
        
        // example using ACE Annotations
    function addAceAnnotations(aceEditor, aceAnnotations) {
            var annotations = aceEditor.getSession().getAnnotations();	
            annotations= annotations.concat(aceAnnotations);
    		aceEditor.getSession().setAnnotations(annotations);
    }
    
    // usage: editor.on("afterRender", updateTraceAnnotations(editor)) // reuires DOM access [Aurelia: call within attached()]
    function updateTraceAnnotations(editor) {
        let dom = document;
        let gutter = editor.renderer.$gutterLayer;
        session.gutterRenderer = traceGutterRenderer;
        let config = editor.renderer.layerConfig;
        let session = editor.getSession();
        let firstRow = config.firstRow;
        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar
            session.getLength() - 1);
        var fold = session.getNextFoldLine(firstRow);
        var foldStart = fold ? fold.start.row : Infinity;
        var foldWidgets = gutter.$showFoldWidgets && session.foldWidgets;
        var breakpoints = session.$breakpoints;
        var decorations = session.$decorations;
        var firstLineNumber = session.$firstLineNumber;
        var lastLineNumber = 0;
        
        var gutterRenderer = session.gutterRenderer || gutter.$renderer;

        var cell = null;
        var index = -1;
        var row = firstRow;
        while (true) {
            if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
                while (gutter.$cells.length > index + 1) {
                    cell = gutter.$cells.pop();
                    gutter.element.removeChild(cell.element);
                }
                break;
            }

            cell = gutter.$cells[++index];
            if (!cell) {
                cell = {element: null, textNode: null, foldWidget: null};
                cell.element = dom.createElement("div");
                cell.textNode = document.createTextNode('');
                cell.element.appendChild(cell.textNode);
                gutter.element.appendChild(cell.element);
                gutter.$cells[index] = cell;
            }

            var className = "ace_gutter-cell ";
            if (breakpoints[row])
                className += breakpoints[row];
            if (decorations[row])
                className += decorations[row];
            if (gutter.$annotations[row])
                className += gutter.$annotations[row].className;
            if (cell.element.className != className)
                cell.element.className = className;

            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
                cell.element.style.height = height;

            if (foldWidgets) {
                var c = foldWidgets[row];
                // check if cached value is invalidated and we need to recompute
                if (c == null)
                    c = foldWidgets[row] = session.getFoldWidget(row);
            }

            if (c) {
                if (!cell.foldWidget) {
                    cell.foldWidget = dom.createElement("span");
                    cell.element.appendChild(cell.foldWidget);
                }
                var className = "ace_fold-widget ace_" + c;
                if (c == "start" && row == foldStart && row < fold.end.row)
                    className += " ace_closed";
                else
                    className += " ace_open";
                if (cell.foldWidget.className != className)
                    cell.foldWidget.className = className;

                var height = config.lineHeight + "px";
                if (cell.foldWidget.style.height != height)
                    cell.foldWidget.style.height = height;
            } else {
                if (cell.foldWidget) {
                    cell.element.removeChild(cell.foldWidget);
                    cell.foldWidget = null;
                }
            }
            
            var text = lastLineNumber = gutterRenderer
                ? gutterRenderer.getText(session, row)
                : row + firstLineNumber;
            if (text != cell.textNode.data)
                cell.textNode.data = text;

            row++;
        }
         gutter.element.style.height = config.minHeight + "px";

        if (gutter.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;

        var gutterWidth = gutterRenderer 
            ? gutterRenderer.getWidth(session, lastLineNumber, config)
            : lastLineNumber.toString().length * config.characterWidth;
        
        var padding = gutter.$padding || gutter.$computePadding();
        gutterWidth += padding.left + padding.right;
        if (gutterWidth !== gutter.gutterWidth && !isNaN(gutterWidth)) {
            gutter.gutterWidth = gutterWidth;
            gutter.element.style.width = Math.ceil(gutter.gutterWidth) + "px";
            gutter._emit("changeGutterWidth", gutterWidth);
        }
    }
    
    let gutterRenderer =  {
        getWidth: function(session, lastLineNumber, config) {
            return lastLineNumber.toString().length * config.characterWidth;
        },
        getText: function(session, row) {
            return String.fromCharCode(row + 65) + "|" + row;
        }
    };
    
    
    
    function getTraceGutterData(trace){
		    let result = {  maxCount : 0, rows : []  };
    
            for (let i = 0; i < trace.length; i ++) {
                let entry = trace[i];
    			let row = entry.range.start.row;
    			
                result.rows[row] = entry.count;
                
                if(result.maxCount< entry.count){
                    result.maxCount = entry.count;
                }
            }
            
            
            return result;
		}
    // use only after execution trace ends
    function updateTraceGutterData(){
        let trace = window.TRACE.getStackTrace();
        
        let localTraceGutterData = getTraceGutterData(trace);
        traceGutterData.maxCount = localTraceGutterData.maxCount;
        traceGutterData.rows = localTraceGutterData.rows;
    }
    
    function initTraceGutterData(){
        traceGutterData  = {  maxCount : 0, rows : []  };
    }
    
    // use after the editor is created
    function setTraceGutterRenderer(editor){
        initTraceGutterData();
        let session = editor.getSession(); // maybe attach the gutterdata to the session?
        let traceGutterRenderer =  {
            getWidth: function(session, lastLineNumber, config) {
                let format = "";
                if(traceGutterData.maxCount > 0){
                    format = "[] ";// adds the brackets and space chars 
                }
                
                return (format.length + traceGutterData.maxCount.toString().length + lastLineNumber.toString().length )* config.characterWidth;
            },
            getText: function(session, row) {
                if(traceGutterData.rows.hasOwnProperty(row)){
                    let count = traceGutterData.rows[row]; // "never" 0
                    return "["+ count +"] "+ row;
                }else{
                    return row;
                }
            }
        };
        session.gutterRenderer = traceGutterRenderer;
    }

</script>
</body>
</html>